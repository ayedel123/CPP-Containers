//#include "header.h"
//
// TEST(ArrayTest, DefaultConstructor) {
// s21::array<int, 5> arr;
// EXPECT_EQ(arr.size(), 5);
// for (size_t i = 0; i < arr.size(); ++i) {
// EXPECT_EQ(arr[i], 0);
//}
//}
//
// TEST(ArrayTest, InitListConstructor) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// EXPECT_EQ(arr.size(), 5);
// for (size_t i = 0; i < arr.size(); ++i) {
// EXPECT_EQ(arr[i], static_cast<int>(i) + 1);
//}
//}
//
// TEST(ArrayTest, CopyConstructor) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// s21::array<int, 5> arrCopy(arr);
// EXPECT_EQ(arrCopy.size(), 5);
// for (size_t i = 0; i < arr.size(); ++i) {
// EXPECT_EQ(arrCopy[i], arr[i]);
//}
//}
//
// TEST(ArrayTest, MoveConstructor) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// s21::array<int, 5> arrMoved(std::move(arr));
// EXPECT_EQ(arrMoved.size(), 5);
// for (size_t i = 0; i < arrMoved.size(); ++i) {
// EXPECT_EQ(arrMoved[i], static_cast<int>(i) + 1);
//}
//}
//
// TEST(ArrayTest, Begin) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// auto it = arr.begin();
// EXPECT_EQ(*it, 1);
//*it = 10;
// EXPECT_EQ(arr[0], 10);
//}
//
// TEST(ArrayTest, End) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// auto it = arr.end();
// auto beginIt = arr.begin();
// EXPECT_EQ(it, beginIt + 5);
//}
//
// TEST(ArrayTest, CBegin) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// auto it = arr.begin();
// EXPECT_EQ(*it, 1);
//}
//
// TEST(ArrayTest, CEnd) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// auto it = arr.cend();
//// cend() iterator should not be dereferenced; comparing it to another
//// iterator should work
// auto beginIt = arr.cbegin();
// EXPECT_EQ(it, beginIt + 5);
// }
//
//// TEST(ArrayTest, At_ValidIndex) {
//// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
//// int value = arr.at(2);
//// EXPECT_EQ(value, 3);
//// }
//
// TEST(ArrayTest, At_OutOfBounds) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
//// Attempting to access an out-of-bounds index using at() should throw an
//// exception
// EXPECT_THROW(arr.at(10), std::out_of_range);
// }
//
// TEST(ArrayTest, ConstAt_ValidIndex) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// int value = arr.at(2);
// EXPECT_EQ(value, 3);
// }
//
// TEST(ArrayTest, ConstAt_OutOfBounds) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
//// Attempting to access an out-of-bounds index using const at() should throw
//// an exception
// EXPECT_THROW(arr.at(10), std::out_of_range);
// }
//
// TEST(ArrayTest, Front) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// int value = arr.front();
// EXPECT_EQ(value, 1);
// }
//
// TEST(ArrayTest, Back) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// int value = arr.back();
// EXPECT_EQ(value, 5);
// }
//
// TEST(ArrayTest, ConstFront) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// int value = arr.front();
// EXPECT_EQ(value, 1);
// }
//
// TEST(ArrayTest, ConstBack) {
// const s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// int value = arr.back();
// EXPECT_EQ(value, 5);
// }
//
// TEST(ArrayTest, Empty_NonEmptyArray) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// EXPECT_FALSE(arr.empty());
// }
//
// TEST(ArrayTest, Empty_EmptyArray) {
// s21::array<int, 0> arr;
// EXPECT_TRUE(arr.empty());
// }
//
// TEST(ArrayTest, Size_NonEmptyArray) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
// EXPECT_EQ(arr.size(), 5);
// }
//
// TEST(ArrayTest, Size_EmptyArray) {
// s21::array<int, 0> arr;
// EXPECT_EQ(arr.size(), 0);
// }
//
// TEST(ArrayTest, MaxSize) {
// s21::array<int, 5> arr;
//// The max size of an array with a specified size is the same as its declared
//// size
// EXPECT_EQ(arr.max_size(), 5);
// }
//
// TEST(ArrayTest, Swap) {
// s21::array<int, 5> arr1 = {1, 2, 3, 4, 5};
// s21::array<int, 5> arr2 = {6, 7, 8, 9, 10};
//
// arr1.swap(arr2);
//
//// Check that the elements of arr1 are now from arr2
// for (size_t i = 0; i < arr1.size(); ++i) {
// EXPECT_EQ(arr1[i], static_cast<int>(i) + 6);
// }
//
//// Check that the elements of arr2 are now from arr1
// for (size_t i = 0; i < arr2.size(); ++i) {
// EXPECT_EQ(arr2[i], static_cast<int>(i) + 1);
// }
// }
//
// TEST(ArrayTest, Fill) {
// s21::array<int, 5> arr;
// arr.fill(10);
//
//// Check that all elements are filled with the specified value
// for (size_t i = 0; i < arr.size(); ++i) {
// EXPECT_EQ(arr[i], 10);
// }
// }
//
//// TEST(ArrayTest, CopyAssignmentOperator) {
//// s21::array<int, 5> arr1 = {1, 2, 3, 4, 5};
//// s21::array<int, 5> arr2 = {6, 7, 8, 9, 10};
////
//// arr1 = arr2;
////
////// Check that arr1 now contains the same elements as arr2
//// for (size_t i = 0; i < arr1.size(); ++i) {
//// EXPECT_EQ(arr1[i], arr2[i]);
//// }
//// }
//
// TEST(ArrayTest, MoveAssignmentOperator) {
// s21::array<int, 5> arr1 = {1, 2, 3, 4, 5};
// s21::array<int, 5> arr2 = {6, 7, 8, 9, 10};
//
// arr1 = std::move(arr2);
//
//// Check that arr1 now contains the same elements as arr2
// for (size_t i = 0; i < arr1.size(); ++i) {
// EXPECT_EQ(arr1[i], static_cast<int>(i) + 6);
// }
// }
//
// TEST(ArrayTest, OperatorBracket) {
// s21::array<int, 5> arr = {1, 2, 3, 4, 5};
//
//// Check that elements can be accessed using the [] operator
// for (size_t i = 0; i < arr.size(); ++i) {
// EXPECT_EQ(arr[i], static_cast<int>(i) + 1);
// }
//
//// Modify an element using the [] operator and check if the array is updated
// arr[2] = 10;
// EXPECT_EQ(arr[2], 10);
// }